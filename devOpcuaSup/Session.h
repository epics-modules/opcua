/*************************************************************************\
* Copyright (c) 2018-2021 ITER Organization.
* This module is distributed subject to a Software License Agreement found
* in file LICENSE that is included with this distribution.
\*************************************************************************/

/*
 *  Author: Ralph Lange <ralph.lange@gmx.de>
 *
 *  based on prototype work by Bernhard Kuner <bernhard.kuner@helmholtz-berlin.de>
 */

#ifndef DEVOPCUA_SESSION_H
#define DEVOPCUA_SESSION_H

#include <string>
#include <set>
#include <map>
#include <cstring>
#include <fstream>

#include <limits.h>

#if defined(_WIN32)
#include <winsock2.h>
#else
#include <unistd.h>
#endif

#include <shareLib.h>
#include <epicsThread.h>
#include <epicsTimer.h>
#include <errlog.h>

#include "iocshVariables.h"

#ifndef HOST_NAME_MAX
  #define HOST_NAME_MAX 256
#endif

namespace DevOpcua {

/**
 * @brief The Session interface to the client side OPC UA session.
 *
 * Main interface for connecting with any OPC UA Server.
 * The implementation manages the connection to an OPC Unified Architecture
 * server and the application session established with it.
 *
 * The connect call establishes and maintains a Session with a Server.
 *
 * The disconnect call disconnects the Session, deleting all Subscriptions
 * and freeing all related resources on both server and client.
 */

class epicsShareClass Session
{
public:
    virtual ~Session() {}

    /**
     * @brief Connect the underlying OPC UA Session.
     *
     * Try connecting the session to the OPC UA server.
     *
     * Non-blocking. Connection status changes shall be reported through a
     * callback interface.
     *
     * If the connection attempt fails and the autoConnect flag is true,
     * the reconnect timer shall be restarted.
     *
     * The manual parameter does not affect the OPC UA functional part, but
     * enables printing the result of the connect service.
     * (Logging failures because of autoconnect attempts is suppressed.)
     *
     * @param manual  set if called as a result of a manual action
     * @return long status (0 = OK)
     */
    virtual long connect(bool manual=true) = 0;

    /**
     * @brief Disconnect the underlying OPC UA Session.
     *
     * Disconnect the session from the OPC UA server.
     *
     * This shall delete all subscriptions related to the session on both client
     * and server side, and free all connected resources.
     * The disconnect shall complete and the status change to disconnected even
     * if the underlying service fails and a bad status is returned.
     *
     * The call shall block until all outstanding service calls and active
     * client-side callbacks have been completed.
     * Those are not allowed to block, else client deadlocks will appear.
     *
     * Connection status changes shall be reported through a callback
     * interface.
     *
     * @return long status (0 = OK)
     */
    virtual long disconnect() = 0;

    /**
     * @brief Return connection status of the underlying OPC UA Session.
     *
     * @return bool connection status
     */
    virtual bool isConnected() const = 0;

    /**
     * @brief Get session name.
     *
     * @return const std::string & name
     */
    virtual const std::string & getName() const = 0;

    /**
     * @brief Print configuration and status on stdout.
     *
     * The verbosity level controls the amount of information:
     * 0 = one line
     * 1 = session line, then one line per subscription
     *
     * @param level  verbosity level
     */
    virtual void show(const int level) const = 0;

    /**
     * @brief Print configuration and status of all sessions on stdout.
     *
     * The verbosity level controls the amount of information:
     * 0 = one summary
     * 1 = one line per session
     * 2 = one session line, then one line per subscription
     *
     * @param level  verbosity level
     */
    static void showAll(const int level);

    /**
     * @brief Do a discovery and show the available endpoints.
     */
    virtual void showSecurity() = 0;

    /**
     * @brief Show client security setup and certificate info.
     */
    static void showClientSecurity();

    /**
     * @brief Set an option for the session.
     *
     * @param name   option name
     * @param value  value
     */
    virtual void setOption(const std::string &name, const std::string &value) = 0;

    /**
     * @brief Add namespace index mapping (local index -> URI).
     *
     * @param nsIndex  local namespace index
     * @param uri  namespace URI
     */
    virtual void addNamespaceMapping(const unsigned short nsIndex, const std::string &uri) = 0;

    /**
     * @brief Factory method to create a session (implementation specific).
     *
     * @param name         name of the new session
     * @param url          url of the server to connect
     * @param debuglevel   initial debug level
     * @param autoconnect  connect automatically at IOC init
     *
     * @return  pointer to the new session, nullptr if not created
     */
    static Session *createSession(const std::string &name,
                                  const std::string &url);

    /**
     * @brief Find a session by name (implementation specific).
     *
     * @param name  session name to search for
     *
     * @return  pointer to session, nullptr if not found
     */
    static Session *find(const std::string &name);

    /**
     * @brief Find sessions with names matching a glob pattern.
     *
     * @param pattern  session name pattern to match
     *
     * @return  set of pointers to matching sessions
     */
    static std::set<Session *> glob(const std::string &pattern);

    /**
     * @brief Set client certificate (public key, private key) file paths.
     *
     * @param pubPath  full path to certificate (public key)
     * @param prvPath  full path to private key file
     */
    static void setClientCertificate(const std::string &&pubKey, const std::string &&prvKey)
    {
        securityClientCertificateFile = std::move(pubKey);
        securityClientPrivateKeyFile = std::move(prvKey);
    }

    /**
     * @brief Setup client PKI (cert store locations).
     *
     * @param certTrustList  server certificate location
     * @param certRevocationList  server revocation list location
     * @param issuersTrustList  issuers certificate location
     * @param issuersRevocationList  issuers revocation list location
     */
    static void setupPKI(const std::string &&certTrustList,
                         const std::string &&certRevocationList,
                         const std::string &&issuersTrustList,
                         const std::string &&issuersRevocationList);

    /**
     * @brief Enable saving of rejected (untrusted) server certificates.
     *
     * @param location  location for saving rejected certs (empty = use default)
     */
    static void saveRejected(const std::string &location = "");

    static const char optionUsage[]; /**< option info for the specific implementation */

    int debug; /**< debug verbosity level */

    static epicsThreadOnceId onceId;  /**< epicsThreadOnce id */
    static void initOnce(void *junk); /**< epicsThreadOnce runner */

protected:
    Session(const std::string &name)
        : debug(0)
        , name(name)
        , autoConnector(*this, opcua_ConnectTimeout, queue)
        , autoConnect(true)
    {
        char host[HOST_NAME_MAX] = {0};
        int status = gethostname(host, sizeof(host));
        if (status)
            strcpy(host, "unknown-host");
        hostname = host;

        const char *ioc = std::getenv("IOC");
        if (!ioc)
            ioc = "ioc";
        iocname = ioc;

        applicationUri = "urn:" + iocname + "@" + hostname + ":EPICS:IOC";

        if (securitySaveRejectedDir.empty()) {
#if defined(_WIN32)
            std::string tempdir(getenv("LOCALAPPDATA"));
            std::string basedir = tempdir + "\\OPC_UA\\";
#else
            std::string basedir("/tmp/");
#endif
            securitySaveRejectedDir = basedir + iocname + "@" + hostname;
        }
    }

    static std::string hostname;
    static std::string iocname;
    static std::string applicationUri;
    static std::string securityCertificateTrustListDir;  /**< trusted server certs location */
    static std::string
        securityCertificateRevocationListDir;            /**< server cert revocation lists location */
    static std::string securityIssuersCertificatesDir;   /**< trusted issuer certs location */
    static std::string securityIssuersRevocationListDir; /**< issuer cert revocation lists location */
    static std::string securityClientCertificateFile;    /**< full path to the client cert (public key) */
    static std::string securityClientPrivateKeyFile;     /**< full path to the client private key */
    static bool securitySaveRejected;                    /**< flag: save rejected (untrusted) certs */
    static std::string securitySaveRejectedDir;          /**< rejected certificates location */

    /**
     * @brief std::map of (URI, name) pairs for all supported security policies.
     */
    static const std::map<std::string, std::string> securitySupportedPolicies;
    /** @brief URI to name converter. */
    static const std::string securityPolicyString(const std::string &policy);

    /**
     * @brief Determine if a file contains PEM encoded keys or certificates.
     *
     * @param file  file name
     *
     * @return true if file uses PEM format
     */
    static bool
    isPEM(const std::string &file)
    {
        if (file.length()) {
            std::ifstream inFile;
            std::string line;
            bool foundPemMarker = false;

            inFile.open(file);
            if (inFile.fail()) {
                errlogPrintf("OPC UA: cannot open file %s\n", file.c_str());
                return false;
            }

            while (std::getline(inFile, line)) {
                size_t cert = line.find("-----BEGIN CERTIFICATE-----");
                size_t key = line.find("-----BEGIN RSA PRIVATE KEY-----");
                if (!(cert && key))
                    foundPemMarker = true;
            }
            return foundPemMarker;
        } else {
            return false;
        }
    }

    /** @brief Replace invalid characters in file name with '_' */
    static std::string
    replaceInvalidFilenameChars(const std::string &name)
    {
        static const std::string invalid = "<>:\"/\\|?*";
        std::string cleaned = name;
        for (auto it = cleaned.begin(); it != cleaned.end(); ++it)
            if (invalid.find(*it) != invalid.npos)
                *it = '_';
        return cleaned;
    }

    /** @brief Delay timer for reconnecting whenever connection is down. */
    class AutoConnect : public epicsTimerNotify {
    public:
        AutoConnect(Session &client, const double delay, epicsTimerQueueActive *queue)
            : timer(queue->createTimer())
            , client(client)
            , delay(delay)
        {}
        virtual ~AutoConnect() override { timer.destroy(); }
        void start() { timer.start(*this, delay); }
        virtual expireStatus expire(const epicsTime &/*currentTime*/) override {
            client.connect(false);
            return expireStatus(noRestart); // client.connect() starts the timer on failure
        }
    private:
        epicsTimer &timer;
        Session &client;
        const double delay;
    };

    static epicsTimerQueueActive *queue;   /**< timer queue for session reconnects */

    const std::string name;                /**< unique session name */
    AutoConnect autoConnector;             /**< reconnection timer */
    bool autoConnect;                      /**< auto (re)connect flag */
    std::string securityIdentityFile;      /**< full path to file with Identity token settings */
    std::string securityUserName;          /**< user name set in Username token */

    const int no_of_properties_read = 2;   /* always read type and value */
};


} // namespace DevOpcua

#endif // DEVOPCUA_SESSION_H
